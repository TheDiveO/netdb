// Copyright 2021 Harald Albrecht.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy
// of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.

package main

import (
	"encoding/base64"
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/thediveo/netdb"
	"github.com/xanzy/go-gitlab"
)

const (
	debianGitlabUrl    = "https://salsa.debian.org"
	debianGitlabAPIUrl = debianGitlabUrl + "/api/v4"
	netbaseProjectID   = "md/netbase"
)

var headerTemplate = template.Must(template.New("").Parse(`// Code generated by go generate. DO NOT EDIT.

// Generated from Debian project {{.Project}} at {{.Url}}
// At {{.Timestamp.Format "2006-01-02T15:04:05Z07:00"}}
// File {{.File}}
// Commit {{.Commit}}

package netdb

`))

func genHeader(w io.Writer, filename string, commit string) {
	if err := headerTemplate.Execute(w, struct {
		Project   string
		Url       string
		Timestamp time.Time
		File      string
		Commit    string
	}{
		Project:   netbaseProjectID,
		Url:       debianGitlabUrl,
		Timestamp: time.Now().UTC(),
		File:      filename,
		Commit:    commit,
	}); err != nil {
		panic(err)
	}
}

// Generate builtin_ethertypes.go based on a freshly fetched /etc/ethertypes
// from the Debian md/netbase project.
func genEtherTypes(git *gitlab.Client) {
	ethertypesTemplate := template.Must(template.New("").Parse(`var BuiltinEtherTypes []EtherType = builtinEtherTypes
var builtinEtherTypes = []EtherType{
	{{- range . }}
		{ Name: {{ printf "%q" .Name }}, Number: {{ printf "%d" .Number }}, Comment: {{ printf "%q" .Comment }}, Aliases: []string{
				{{- range .Aliases -}}
					{{- printf "%q" . }},
				{{- end -}}
			} },
	{{- end }}
	}
	`))

	fmt.Printf("fetching etc/ethertypes from md/netbase Debian repository...\n")
	f, resp, err := git.RepositoryFiles.GetFile(
		netbaseProjectID,
		"etc/ethertypes",
		&gitlab.GetFileOptions{
			Ref: gitlab.String("master"),
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("latest commit ID: %s\n", f.LastCommitID)
	defer resp.Body.Close()
	ethertypes, err := netdb.ParseEtherTypes(
		base64.NewDecoder(
			base64.StdEncoding,
			strings.NewReader(f.Content)))
	if err != nil {
		panic(err)
	}
	if len(ethertypes) < 2 {
		panic("not enough ethertypes found; invalid /etc/ethertypes?")
	}
	fmt.Printf("%d ethertypes found\n", len(ethertypes))

	fmt.Printf("generating builtin_ethertypes.go...\n")
	gof, err := os.Create("builtin_ethertypes.go")
	if err != nil {
		panic(err)
	}
	defer gof.Close()
	genHeader(gof, "etc/ethertypes", f.LastCommitID)
	if err := ethertypesTemplate.Execute(gof, ethertypes); err != nil {
		panic(err)
	}
	fmt.Printf("done\n")
}

// Generate builtin/protocols.go based on a freshly fetched /etc/protocols from
// the Debian md/netbase project.
func genProtocols(git *gitlab.Client) []netdb.Protocol {
	protocolsTemplate := template.Must(template.New("").Parse(`var BuiltinProtocols []Protocol = builtinProtocols
var builtinProtocols = []Protocol{
	{{- range . }}
		{ Name: {{ printf "%q" .Name }}, Number: {{ printf "%d" .Number }}, Aliases: []string{
				{{- range .Aliases -}}
					{{- printf "%q" . }},
				{{- end -}}
			} },
	{{- end }}
	}
	`))

	fmt.Printf("fetching etc/protocols from md/netbase Debian repository...\n")
	f, resp, err := git.RepositoryFiles.GetFile(
		netbaseProjectID,
		"etc/protocols",
		&gitlab.GetFileOptions{
			Ref: gitlab.String("master"),
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("latest commit ID: %s\n", f.LastCommitID)
	defer resp.Body.Close()
	protocols, err := netdb.ParseProtocols(
		base64.NewDecoder(
			base64.StdEncoding,
			strings.NewReader(f.Content)))
	if err != nil {
		panic(err)
	}
	if len(protocols) < 2 {
		panic("not enough protocols found; invalid /etc/protocols?")
	}
	fmt.Printf("%d protocols found\n", len(protocols))

	fmt.Printf("generating builtin_protocols.go...\n")
	gof, err := os.Create("builtin_protocols.go")
	if err != nil {
		panic(err)
	}
	defer gof.Close()
	genHeader(gof, "etc/protocols", f.LastCommitID)
	if err := protocolsTemplate.Execute(gof, protocols); err != nil {
		panic(err)
	}
	fmt.Printf("done\n")
	return protocols
}

func genServices(git *gitlab.Client, protos []netdb.Protocol) {
	protoindices := map[string]int{}
	for idx, proto := range protos {
		protoindices[proto.Name] = idx
		for _, alias := range proto.Aliases {
			protoindices[alias] = idx
		}
	}
	servicesTemplate := template.Must(template.New("").Funcs(template.FuncMap{
		"protoref": func(protocol string) (string, error) {
			if idx, ok := protoindices[protocol]; ok {
				return fmt.Sprintf("&BuiltinProtocols[%d]", idx), nil
			}
			return "", fmt.Errorf("unknown protocol %q", protocol)
		},
	}).Parse(`var BuiltinServices []Service = builtinServices
var builtinServices = []Service{
	{{- range . }}
		{ Name: {{ printf "%q" .Name }}, Port: {{ printf "%d" .Port }}, ProtocolName: {{ printf "%q" .ProtocolName }}, Protocol: {{ protoref .ProtocolName }} , Aliases: []string{
				{{- range .Aliases -}}
					{{- printf "%q" . }},
				{{- end -}}
			} },
	{{- end }}
	}
	`))

	fmt.Printf("fetching etc/services from md/netbase Debian repository...\n")
	f, resp, err := git.RepositoryFiles.GetFile(
		netbaseProjectID,
		"etc/services",
		&gitlab.GetFileOptions{
			Ref: gitlab.String("master"),
		})
	if err != nil {
		panic(err)
	}
	fmt.Printf("latest commit ID: %s\n", f.LastCommitID)
	defer resp.Body.Close()
	services, err := netdb.ParseServices(
		base64.NewDecoder(
			base64.StdEncoding,
			strings.NewReader(f.Content)),
		netdb.NewProtocolIndex(protos))
	if err != nil {
		panic(err)
	}
	if len(services) < 100 {
		panic("not enough services found; invalid /etc/services?")
	}
	fmt.Printf("%d services found\n", len(services))

	fmt.Printf("generating builtin_services.go...\n")
	gof, err := os.Create("builtin_services.go")
	if err != nil {
		panic(err)
	}
	defer gof.Close()
	genHeader(gof, "etc/services", f.LastCommitID)
	if err := servicesTemplate.Execute(gof, services); err != nil {
		panic(err)
	}
	fmt.Printf("done\n")
}

// Fetch /etc/protocols and /etc/services from the netbase package of the Debian
// project and generate the static "builtin" go files from its contents.
func main() {
	debgit, err := gitlab.NewClient("", gitlab.WithBaseURL(debianGitlabAPIUrl))
	if err != nil {
		panic(err)
	}
	genEtherTypes(debgit)
	protocols := genProtocols(debgit)
	genServices(debgit, protocols)
}
